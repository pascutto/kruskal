\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage[french]{babel}

\usetheme{Warsaw}

\title[Algorithme de Kruskal]{Algorithme de Kruskal\\Application au 
problème du voyageur de commerce}
\author{Mihai Dusmanu, Clément Pascutto}
\institute{Algorithmique et programation\\École normale supérieure}
\date{Vendredi 8 Janvier 2016}


\begin{document}

    \begin{frame}
		\titlepage
    \end{frame}

	\begin{frame}
		\frametitle{Sommaire}
		\tableofcontents
	\end{frame}

	\section{Outils}

		\subsection{Tri hybride}

			%\subsubsection{Algorithme}
			\begin{frame}
				\frametitle{Algorithme}

				On utilise un algorithme de tri rapide faisant appel à un
				tri par insertion pour les petits tableaux.
				\\~\\	
				\begin{algorithm}[H]
					\caption{Tri hybride du tableau t}
					\begin{algorithmic}[H]
						\IF{$taille(t) < minLength$} 
						\STATE{trier t avec un tri par insertion;} 
						\ELSE \STATE{
							prendre un pivot p;\\
							partitionner t selon le pivot p;\\
							trier récursivement les deux tableaux obtenus;
						}
						\ENDIF
					\end{algorithmic}
				\end{algorithm}

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			%\subsubsection{Choix de minLength}
			\begin{frame}
				\frametitle{Choix de \emph{minLength}}
				
				Le choix est fait empiriquement après plusieurs tests.

				Insérer les graphes.

				On retient finalement la valeur $20$.

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			%\subsubsection{Choix du pivot}
			\begin{frame}
				\frametitle{Choix du pivot}

				On implémente la méthode \emph{median of three} : 
				
				\begin{itemize}
					\item On considère les éléments de tête, queue et
						milieu du tableau à trier.
					\item On ordonne ces trois éléments dans le tableau.
					\item On prend la médiane de ces trois éléments comme
						pivot.
				\end{itemize}

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\begin{frame}
				\frametitle{Choix du pivot}
				\framesubtitle{Comparaison des différents choix de pivot}

				Insérer les graphes.

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			%\subsubsection{Complexité}
			\begin{frame}
				\frametitle{Complexité}

				Insérer les graphes.

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Union-Find}
			\begin{frame}
				\frametitle{Présentation de la structure Union-Find}
				
				Union-find est une structure de données utilisée pour
				représenter une partition d'un ensemble.
				
				Elle a trois primitives :
				\begin{itemize}
					\item \texttt{new}($n$) crée une nouvelle structure
						Union-Find de taille $n$.
					\item \texttt{find}($x$) renvoie le représentant de
						la classe de $x$.
					\item \texttt{union}($x,y$) fusionne les classe de
						$x$ et $y$.
				\end{itemize}
			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\begin{frame}
				\frametitle{Présentation de la structure Union-Find}

				Insérer exemple
			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\begin{frame}
				\frametitle{Première optimisation}
					
				
			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\begin{frame}
				\frametitle{Seconde optimisation}

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\begin{frame}
				\frametitle{Complexité en moyenne}

				Récapitulatif des complexités de Union-Find pour $m$
				opérations sur un structure de taille $n$ :
				\\~\\
				\begin{tabular}{|c|c|c|c|c|}
					\hline
					Primitive & $\varnothing$ & 1 & 2 & 1 \& 2
					\\
					\hline
					\texttt{new} & $\mathcal{O}(n)$ & $\mathcal{O}(n)$
					& $\mathcal{O}(n)$ & $\mathcal{O}(n)$
					\\
					\hline
					\texttt{find} & $\mathcal{O}(n)$ &
					$\mathcal{O}(\max(1,\frac
						{\log\frac{n^{2}}{m}}
						{\log\frac{2m}{n}}))$ &
					$\log(n)$ & $\alpha(m,n)$ 
					\\
					\hline
				\end{tabular}

			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\subsection{Générateur de graphes}
			\begin{frame}
				\frametitle{Contraintes du générateur}
				On doit créer un graphe :
				\begin{itemize}
					\item avec un nombre fixé de sommets
					\item avec un nombre fixé d'arêtes
					\item connexe
					\item uniformément distribué
					\item rapidement
				\end{itemize}
				Notre algorithme permet une telle génération en temps linéaire.
			\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			\begin{frame}
				\frametitle{Algorithme}
				
				\begin{algorithm}[H]
					\caption{Génération d'un graphe à n sommets
					et m arêtes}
					\begin{algorithmic}[H]
						\STATE $S,V \leftarrow \varnothing$
						\STATE $T \leftarrow \sigma\left\{1,...,n\right\}$
						\FOR {$i \in T$}
						\STATE $V \leftarrow V\cup\left\{(i,rand(S))\right\}$
						\STATE $S \leftarrow S\cup\left\{i\right\}$
						\STATE $T \leftarrow T\backslash\left\{i\right\}$
						\ENDFOR
						\STATE ajouter $m-n$ arêtes aléatoires à $V$
						\RETURN $(S,V)$
					\end{algorithmic}
				\end{algorithm}
				La complexité de cet algorithme est $\mathcal{O}(m)$
			\end{frame}

	\section{Algorithme de Kruskal}
	
	\subsection{Présentation}
		\begin{frame}
			\frametitle{Présentation de l'algorithme}
				
			\begin{algorithm}[H]
				\caption{Algorithme de Kruskal sur $G=(V,E)$}
				\begin{algorithmic}[H]
					\STATE $A \leftarrow \varnothing$
					\STATE trier $E$ par poids croissants
					\FOR {$(x,y,p)\in E$}
						\IF {$x$ et $y$ ne sont pas dans la même composante
						connexe}
						\STATE $A \leftarrow A \cup
						\left\{(x,y,p)\right\}$
						\ENDIF
					\ENDFOR
					\RETURN $(V,A)$
				\end{algorithmic}
			\end{algorithm}
		\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		\begin{frame}
			\frametitle{Exemple d'éxécution}

		\end{frame}

	\subsection{Preuve de correction}
		\begin{frame}
			\frametitle{Preuve de correction}
			
			\begin{itemize}
				\item Le graphe renvoyé est clairement un arbre.
				\item On va montrer par induction qu'à tout instant de
					l'algorithme, $\mathcal{P}(A)$ : il existe un ACM
					contenant $A$. 
					\begin{itemize}
						\item $\mathcal{P}(\varnothing)$ est trivialement
							vraie.
						\item Supposons $T$ l'ACM garanti par
							$\mathcal{P}(A)$.\\
							Soit $e$ la prochaine arête.\\
							Si $e \in T$,
							$\mathcal{P}(A\cup\left\{e\right\})$
							est vraie.\\
							Sinon, $T+e$ contient un cycle $C$. Soit $f
							\in C \backslash A$.\\
							$T-f+e$ est un ACM qui contient
							$A\cup\left\{e\right\}$.
					\end{itemize}
			\end{itemize}
		\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\subsection{Complexité}
		\begin{frame}
			\frametitle{Complexité}
			
			Insérer graph
		\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Voyageur de commence}

	\subsection{Algorithme}
		\begin{frame}
			\frametitle{Algorithme}
			
			\begin{algorithm}[H]
				\caption{build\_road($visited, node, edges$)}
				\begin{algorithmic}[H]
					\STATE $visited \leftarrow visited + node$
					\FOR{$(x,y,p)\in$ edges}
						\IF{$x = node$ \AND $y \ne father(node)$}
						\STATE build\_road($visited, y, edges$)
						\ELSE \IF{$y = node$ \AND $x \ne father(node)$}
						\STATE build\_road($visited, v, edges$)
						\ENDIF
						\ENDIF
					\ENDFOR
				\end{algorithmic}
			\end{algorithm}
		
		\end{frame}

	\subsection{Complexité}


\end{document}
